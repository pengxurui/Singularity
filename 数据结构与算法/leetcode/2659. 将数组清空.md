## [2659. 将数组清空](https://leetcode.cn/problems/make-array-empty/)

## 题目描述

给你一个包含若干 互不相同 整数的数组 nums ，你需要执行以下操作 直到数组为空 ：

如果数组中第一个元素是当前数组中的 最小值 ，则删除它。
否则，将第一个元素移动到数组的 末尾 。
请你返回需要多少个操作使 nums 为空。

### 预备知识 - 循环数组

循环数组：将数组尾部元素的后继视为数组首部元素，数组首部元素的前驱视为数组尾部元素。

### 预备知识 - 树状数组

[OI · 树状数组](https://oi-wiki.org/ds/fenwick/#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%85%B6%E6%A0%91%E5%BD%A2%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8)

树状数组也叫二叉索引树（Binary Indexed Tree），是一种支持 “单点修改” 和 “区间查询” 的代码量少的数据结构。相比于线段树来说，树状数组的代码量远远更少，是一种精妙的数据结构。

树状数组核心思想是将数组 [0,x] 的前缀和拆分为不多于 logx 段非重叠的区间，在计算前缀和时只需要合并 logx 段区间信息，而不需要合并 n 个区间信息。同时，在更新单点值时，也仅需要修改 logx 段区间，而不需要（像前缀和数组）那样修改 n 个信息。可以说，树状数组平衡了单点修改和区间和查询的时间复杂度：

- 单点更新 add(index,val)：将序列第 index 位元素增加 val，时间复杂度为 O(lgn)，同时对应于在逻辑树形结构上从小分块节点移动到大分块节点的过程（修改元素会影响大分块节点（子节点）的值）；
- 区间查询 prefixSum(index)：查询前 index 个元素的前缀和，时间复杂度为 O(lgn)，同时对应于在逻辑树形结构上累加区间段的过程。

`树状数组`

![](https://pic.leetcode.cn/1683188751-VcRLpU-Untitled%202.png){:width=400}

### 问题结构化

![](https://pic.leetcode.cn/1683188782-TzmbBq-2659.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%B8%85%E7%A9%BA%EF%BC%88Hard%EF%BC%89-%E5%8E%BB%E6%B0%B4%E5%8D%B0.png){:width=400}

#### 1、概括问题目标

求消除数组的操作次数。

#### 2、分析题目要件

- 观察：在每次操作中，需要观察数组首部元素是否为剩余元素中的最小值。例如序列 [3,2,1] 的首部元素不是最小值；
- 消除：在每次操作中，如果数组首部元素是最小值，则可以消除数组头部元素。例序列 [1,2,3] 在一次操作后变为 [2,3]；
- 移动：在每次操作中，如果数组首部元素不是最小值，则需要将其移动到数组末尾。例如序列 [3,2,1] 在一次操作后变为 [2,1,3]。

#### 3、观察数据特征

- 数据量：测试用例的数据量上界为 10^5，这要求我们实现低于 O(n^2) 时间复杂度的算法才能通过；
- 数据大小：测试用例的数据上下界为 [-10^9, 10^9]，这要求我们考虑大数问题。

#### 4、观察测试用例

以序列 [3,4,-1] 为例，一共操作 5 次：

- [3,4,-1]：-1 是最小值，将 3 和 4 移动到末尾后才能消除 -1，一共操作 3 次；
- [3,4]：3 是最小值，消除 3 操作 1 次；
- [4]：4 是最小值，消除 4 操作 1 次；

#### 5、提高抽象程度

- 序列：线性表是由多个元素组成的序列，除了数组的头部和尾部元素之外，每个元素都有一个前驱元素和后继元素。在将数组首部元素移动到数组末尾时，将改变数组中的部分元素的关系，即原首部元素的前驱变为原尾部元素，原尾部元素的后继变为原首部元素。
- 是否为决策问题：由于每次操作的行为是固定的，因此这道题只是纯粹的模拟问题，并不是决策问题。

#### 6、具体化解决手段

**消除操作需要按照元素值从小到大的顺序删除，那么如何判断数组首部元素是否为最小值？**

- 手段 1（暴力枚举）：枚举数组剩余元素，判断首部元素是否为最小值，单次判断的时间复杂度是 O(n)；
- 手段 2（排序）：对原始数组做预处理排序，由于原始数组的元素顺序信息在本问题中是至关重要的，所以不能对原始数组做原地排序，需要借助辅助数据结构，例如索引数组、最小堆，单次判断的均摊时间复杂度是 O(1)。

**如何表示元素的移动操作：**

- 手段 1（数组）：使用数组块状复制 Arrays.copy()，单次操作的时间复杂度是 O(n)；
- 手段 2（双向链表）：将原始数组转换为双向链表，操作链表首尾元素的时间复杂度是 O(1)，但会消耗更多空间；

**如何解决问题：**

- 手段 1（模拟）：模拟消除和移动操作，直到数组为空。在最坏情况下（降序数组）需要操作 n^2 次，因此无论如何都是无法满足题目的数据量要求；

**至此，问题陷入瓶颈。**

解决方法是重复「分析问题要件」-「具体化解决手段」的过程，枚举掌握的算法、数据结构和 Tricks 寻找突破口：

**表示元素的移动操作的新手段：**

- 手段 3（循环数组）：将原数组视为循环数组，数组尾部元素的后继是数组首部元素，数组首部元素的前驱是数组尾部元素，不再需要实际性的移动操作。

**解决问题的新手段：**

- 手段 2（计数）：观察测试用例发现，消除每个元素的操作次数取决于该元素的前驱中未被消除的元素个数，例如序列 [3,4,-1] 中 -1 前有 2 个元素未被删除，所以需要 2 次操作移动 3 和 4，再增加一次操作消除 -1。那么，我们可以定义 rangeSum(i,j) 表示区间 [i,j] 中未被删除的元素个数，每次消除操作只需要查询上一次的消除位置（上一个最小值）与当前的消除位置（当前的最小值）中间有多少个数字未被消除 rangeSum(上一个最小值位置, 当前的最小值位置)，这个区间和就是消除当前元素需要的操作次数。

区分上次位置与当前位置的前后关系，需要分类讨论：

- id < preId：消除次数 = rangeSum(id, preId)
- id > preId：消除次数 = rangeSum(-1, id) + rangeSum(preId,n - 1)

**如何实现手段 2（计数）：**

在代码实现上，涉及到「区间求和」和「单点更新」可以用线段数和树状数组实现。树状数组的代码量远比线段树少，所以我们选择后者。

`示意图`

![](https://pic.leetcode.cn/1683188764-RWnGzk-Untitled%204.png){:width=400}

**答疑：**

- 消除每个元素的操作次数不用考虑前驱元素中小于当前元素的元素吗？

由于消除是按照元素值从小到大的顺序消除的，所以未被消除的元素一定比当前元素大，所以我们不强调元素大小关系。

### 题解一（树状数组 + 索引数组）

- 使用「树状数组」的手段解决区间和查询和单点更新问题，注意树状数组是 base 1 的；
- 使用「索引数组」的手段解决排序 / 最小值问题。

```kotlin
class Solution {
    fun countOperationsToEmptyArray(nums: IntArray): Long {
        val n = nums.size
        var ret = 0L
        // 索引数组
        val ids = Array<Int>(n) { it }
        // 排序
        Arrays.sort(ids) { i1, i2 ->
            // 考虑大数问题
            // nums[i1] - nums[i2] x
            if (nums[i1] < nums[i2]) -1 else 1
        }
        // 树状数组
        val bst = BST(n)
        // 上一个被删除的索引
        var preId = -1
        // 遍历索引
        for (id in ids) {
            // 区间和
            if (id > preId) {
                ret += bst.rangeSum(preId, id)
                // println("id=$id, ${bst.rangeSum(preId, id)}")
            } else {
                ret += bst.rangeSum(-1, id) + bst.rangeSum(preId, n - 1)
                // println("id=$id, ${bst.rangeSum(-1,id)} + ${bst.rangeSum(preId, n - 1)}")
            }
            // 单点更新
            bst.dec(id)
            preId = id
        }
        return ret
    }

    // 树状数组
    private class BST(private val n: Int) {

        // base 1
        private val data = IntArray(n + 1)

        init {
            // O(nlgn) 建树
            // for (i in 0 .. n) {
            //     update(i, 1)
            // }
            // O(n) 建树
            for (i in 1 .. n) {
                data[i] += 1
                val parent = i + lowbit(i)
                if (parent <= n) data[parent] += data[i]
            }
        }

        fun rangeSum(i1: Int, i2: Int): Int {
            return preSum(i2 + 1) - preSum(i1 + 1)
        }

        fun dec(i: Int) {
            update(i + 1, -1)
        }

        private fun preSum(i: Int): Int {
            var x = i
            var sum = 0
            while (x > 0) {
                sum += data[x]
                x -= lowbit(x)
            }
            return sum
        }

        private fun update(i: Int, delta: Int) {
            var x = i
            while (x <= n) {
                data[x] += delta
                x += lowbit(x)
            }
        }

        private fun lowbit(x: Int) = x and (-x)
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(nlgn)$ 其中 n 是 nums 数组的长度，排序 $O(nlgn)$、树状数组建树 $O(n)$、单次消除操作的区间和查询和单点更新的时间为 $O(lgn)$；
- 空间复杂度：$O(n)$ 索引数组空间 + 树状数组空间。

### 题解二（树状数组 + 最小堆）

附赠一份最小堆排序的代码：

- 使用「树状数组」的手段解决区间和查询和单点更新问题，注意树状数组是 base 1 的；
- 使用「最小堆」的手段解决排序 / 最小值问题。

```kotlin
class Solution {
    fun countOperationsToEmptyArray(nums: IntArray): Long {
        val n = nums.size
        var ret = 0L
        // 最小堆
        val ids = PriorityQueue<Int>() { i1, i2 ->
            if (nums[i1] < nums[i2]) -1 else 1
        }
        for (id in 0 until n) {
            ids.offer(id)
        }
        // 树状数组
        val bst = BST(n)
        // 上一个被删除的索引
        var preId = -1
        // 遍历索引
        while (!ids.isEmpty()) {
            val id = ids.poll()
            // 区间和
            if (id > preId) {
                ret += bst.rangeSum(preId, id)
            } else {
                ret += bst.rangeSum(-1, id) + bst.rangeSum(preId, n - 1)
            }
            // 单点更新
            bst.dec(id)
            preId = id
        }
        return ret
    }
}
```

**复杂度分析：**

- 时间复杂度：$O(nlgn)$ 其中 n 是 nums 数组的长度，堆排序 $O(nlgn)$、树状数组建树 $O(n)$、单次消除操作的区间和查询和单点更新的时间为 $O(lgn)$；
- 空间复杂度：$O(n)$ 堆空间 + 树状数组空间。

**相似题目：**

- [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
- [1040. 移动石子直到连续 II](https://leetcode.cn/problems/moving-stones-until-consecutive-ii)
